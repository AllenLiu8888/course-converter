# 批量课程转换工具（OLX → LiaScript）项目计划

## 1. 背景与目标
- 目标：将 Open edX 的 OLX（XML，打包为 `.tar.gz`）课程批量转换为 LiaScript Markdown（扩展语法的 Markdown），每门课程输出 `course.md` 与 `media/` 目录。
- 约束：采用函数式 JavaScript（Node.js），禁止使用现成的 OLX/LiaScript 转换库；需要具备良好的可维护性、可扩展性和测试覆盖。
- 产出：可执行的 CLI 工具、测试（Jest）、规划与说明文档、示例输入/输出、日志与错误报告。

## 2. 术语与范围
- OLX（Open Learning XML）：Open edX 课程内容的 XML 表达与组织方式，最终以 `.tar.gz` 打包。
- LiaScript Markdown：在 Markdown 之上扩展的教学语法，支持题目、媒体与互动元素。本项目的最终输出为采用 LiaScript 语法的 `course.md`。
- 支持内容类型（MVP → 完整）：
  - 课程/章节/单元标题 → `#`/`##`/`###`
  - About → `## About` 段落
  - HTML → Markdown（图片重写至 `media/`）
  - 视频（YouTube）→ LiaScript 视频嵌入
  - Problems（题目）→ LiaScript 题目语法（单选、多选、填空、下拉），支持 hint
  - 未识别/未发布 → 忽略或插入占位说明

## 3. 端到端流程（E2E）
1) CLI 与输入发现：解析 `--input`（文件或目录）、`--output`、`--concurrency` 等参数；发现所有待处理的 `.tar.gz` 包。
2) 解压与校验：逐个课程包解压到独立临时目录；校验课程根（存在 `course.xml` 等关键结构）。
3) 解析 OLX：使用 XML 解析器将 XML 文本转为 JS 对象，建立 id → 节点 的索引与引用关系，过滤未发布内容。
4) 构建课程逻辑树：按 OLX 引用顺序构建 Course → Chapters → Sequentials → Verticals → Components 的有序树（AST）。
5) 组件级转换（IR）：将各组件转为统一的 LiaScript 中间表示（IR），屏蔽底层差异。
6) 渲染 Markdown：把 IR 渲染为 LiaScript Markdown 文本，确保层级与顺序。
7) 资源处理：复制引用媒体到 `output/{CourseSlug}/media/`，并重写 Markdown 资源路径。
8) 写出结果：生成 `output/{CourseSlug}/course.md` 与 `media/`，输出统计与日志。
9) 批量与健壮性：课程级隔离（独立 try/catch）；可选并发处理与限流，不因单个失败阻断整体。

## 4. 架构与模块划分
- CLI 层：参数解析、输入发现、任务编排、并发与进度、最终汇总。
- IO/读取层：解压、文件系统读取、XML 解析。
- 索引与建树：建立 id 索引与引用关系，生成课程逻辑树（AST）。
- 转换层：组件到 LiaScript IR 的纯函数转换器（about/html/video/problem/unsupported）。
- 渲染层：IR → LiaScript Markdown。
- 资源层：媒体收集、复制、路径重写。
- 错误与日志：结构化错误、课程级隔离、可选调试日志。

## 5. 函数式设计原则
- 纯函数优先：输入相同、输出稳定；无副作用（IO 与纯计算分离）。
- 不可变数据：避免原地修改，使用拷贝或持久化结构。
- 小而专注：单一职责、组合优先。
- 可测试：关键逻辑以纯函数呈现，便于单元测试与快照对比。

## 6. 数据模型（示意，TypeScript 风格）
```ts
type OlxIndex = {
  byId: Record<string, any>;            // 原始 XML → JS 对象
  edges: Record<string, string[]>;      // 父 → 子 id 列表（保序）
  meta: { courseId: string; title: string; about?: string };
};

type CourseTree = {
  id: string;
  title: string;
  chapters: ChapterNode[];
  about?: IRBlock[];                     // 可选：About 预解析
};

type ChapterNode = { id: string; title: string; sequentials: SequentialNode[] };
type SequentialNode = { id: string; title: string; verticals: VerticalNode[] };
type VerticalNode = { id: string; title?: string; components: ComponentNode[] };

type ComponentNode =
  | { kind: 'html'; payload: { html: string } }
  | { kind: 'video'; payload: { youtubeId?: string; url?: string } }
  | { kind: 'problem'; payload: any }
  | { kind: 'about'; payload: { html: string } }
  | { kind: 'unsupported'; payload: { name: string } };

// LiaScript 中间表示（IR）
type IRBlock =
  | { type: 'heading'; level: 1 | 2 | 3; text: string }
  | { type: 'paragraph'; text: string }
  | { type: 'html-md'; markdown: string }
  | { type: 'video'; provider: 'youtube'; id: string }
  | { type: 'problem-mcq'; prompt: string; options: { text: string; correct: boolean }[]; hint?: string }
  | { type: 'problem-input'; prompt: string; answer: string; hint?: string }
  | { type: 'problem-dropdown'; prompt: string; options: string[]; answerIndex: number; hint?: string }
  | { type: 'unsupported'; note: string }
  | { type: 'image'; alt: string; path: string };
```

## 7. 关键流程伪代码
```pseudo
main(argv):
  options ← parseCli(argv)
  tarPaths ← discoverInputs(options.input)
  for each tarPath in planWithConcurrency(tarPaths, options.concurrency):
    try:
      tempDir ← extractTarGzToTemp(tarPath)
      assertCourseRoot(tempDir)          // 检查 course.xml 等
      olxIndex ← parseOlxToIndex(tempDir)
      courseTree ← buildCourseTree(olxIndex)
      liaIR ← transformTreeToLiaIR(courseTree)
      mediaMap ← collectMediaAssets(liaIR, tempDir)
      markdown ← renderLiaIRToMarkdown(liaIR, mediaMap)
      writeCourseOutput(slugFrom(olxIndex), markdown, mediaMap, options.output)
      logSuccess(tarPath)
    catch e:
      logFailure(tarPath, e)
```

## 8. 依赖与工具
- Node.js（LTS）
- 解析/转换：`fast-xml-parser`、`node-html-markdown`（或 `turndown`）、`tar`
- CLI：`commander` 或 `yargs`（可选）
- 测试：`jest`、`@types/jest`（如需 TS 类型提示）
- 代码质量：`eslint`、`prettier`（可选）

## 9. CLI 规范（草案）
- 用法：
  - `course-converter --input <path> --output <dir> [--concurrency 2] [--include-unpublished] [--verbose]`
- 参数：
  - `--input`：单个 `.tar.gz` 文件或包含多个包的目录
  - `--output`：输出根目录
  - `--concurrency`：并发课程数（默认 1）
  - `--include-unpublished`：包含未发布内容（默认否）
  - `--verbose`：详细日志

## 10. 错误处理与日志策略
- 课程级隔离：单个课程失败不影响其它课程继续。
- 结构化错误：错误分级（解析错误、格式错误、IO 错误、转换不支持）。
- 日志内容：输入路径、阶段标记、耗时、失败原因、输出统计（组件数、媒体数）。
- 兜底：找不到支持的组件类型时输出占位说明，并记录 warning。

## 11. 性能与并发
- 默认串行，选项开启并发并限流（避免 IO 峰值）。
- 复用解析器实例与缓存（如需要）。
- 避免多余磁盘写入，统一批量输出。

## 12. 测试计划（Jest）
- 单元测试：
  - `parseOlxToIndex`：给定最小 XML 样例，断言索引结构。
  - `buildCourseTree`：引用顺序与层级正确、未发布过滤。
  - 转换器：`html`/`video`/`problem` → IR 的转换正确性（含边界）。
  - 渲染器：IR → Markdown 的快照测试。
- 集成测试：
  - 输入一个小型示例 `.tar.gz`，比对输出 `course.md` 的快照与 `media/` 数量。
- 端到端（可选）：
  - 多课程批量处理，校验错误隔离、统计与耗时。

## 13. 里程碑与排期（建议）
- M0（今天）：项目计划定稿（本文件）；创建仓库与基础目录。
- M1：CLI 雏形与输入发现；解压与校验；最小课程跑通。
- M2：解析/索引/建树；HTML → Markdown 转换；渲染输出。
- M3：Video/Problem 转换；媒体复制与路径重写；About 渲染。
- M4：测试完善（单元+集成+快照）；错误与日志；并发（可选）。
- M5：文档完善（README、使用示例、AI 使用说明）；最终验收与演示。

## 14. 风险与应对
- OLX 变体众多：以“最常见结构”为主，其他以占位与 warning 兼容。
- 媒体路径复杂：统一收集与重写，保留相对路径策略。
- Problem 题型解析差异：从典型 MCQ/填空/下拉入手，逐步覆盖。
- 大文件性能：限流并发、惰性解压或按需扫描。

## 15. 验收标准与评分映射
- 细节把控：目录规范、依赖与脚本完整、规划文档详尽（本文件 + README）。
- 核心功能：所有指定类型正确转换，顺序与层级保序，批量处理通过。
- 代码与测试：模块化、命名清晰、JSDoc 注释、Jest 覆盖核心模块与快照。
- 函数式范式：纯函数/不可变/组合/可测试，IO 与纯计算分离。

## 16. 交付物清单
- 可运行的 CLI 工具（含 `--help`）。
- 示例输入（一个最小 `.tar.gz`）与示例输出（`course.md` + `media/`）。
- 测试用例与快照。
- 文档：本计划、`README.md`、AI 使用说明。

## 17. AI 使用说明（初稿）
- 使用场景：规划、样板代码生成建议、测试思路、边界用例提示。
- 人审与控制：所有关键实现与转换规则由开发者编写与审核；AI 仅辅助。
- 署名与透明：`README` 标注 AI 支持范围与局限。

## 18. 当日输出（计划达成）
- 本《项目计划》完成并落库。
- 下一步建议：初始化项目目录与 `package.json`，并创建最小 CLI 骨架与解压/校验的占位实现与测试框架。


